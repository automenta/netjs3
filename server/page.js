// Generated by CoffeeScript 1.9.1

/*
 * Federated Wiki : Node Server
 *
 * Copyright Ward Cunningham and other contributors
 * Licensed under the MIT license.
 * https://github.com/fedwiki/wiki-node-server/blob/master/LICENSE.txt
 */
var async, events, exports, fs, glob, mkdirp, path, random_id, synopsis;

//fs = require('fs');

path = require('path');

events = require('events');

glob = require('glob');

//mkdirp = require('mkdirp');

async = require('async');

random_id = require('./random_id');

synopsis = require('../client').synopsis;

module.exports = exports = function (argv, fs) {
    var editDate, fileio, itself, load_parse, load_parse_copy, queue, serial, working;
    fs.mkdir(argv.db, function (e) {
        if (e) {
            console.error('unable to create directory: ' + argv.db)
            //throw e;
        }
    });
    load_parse = function (loc, cb, annotations) {
        if (annotations == null) {
            annotations = {};
        }
        return fs.readFile(loc, function (err, data) {
            var e, key, page, val;
            if (err) {
                return cb(err);
            }
            try {
                page = JSON.parse(data);
            } catch (_error) {
                e = _error;
                return cb(e);
            }
            for (key in annotations) {
                val = annotations[key];
                page[key] = val;
            }
            return cb(null, page);
        });
    };
    load_parse_copy = function (defloc, file, cb) {
        return fs.readFile(defloc, function (err, data) {
            var e, page;
            if (err) {
                cb(err);
            }
            try {
                page = JSON.parse(data);
            } catch (_error) {
                e = _error;
                return cb(e);
            }
            cb(null, page);
            return itself.put(file, page, function (err) {
                if (err) {
                    return cb(err);
                }
            });
        });
    };
    queue = [];
    fileio = function (file, page, cb) {
        var loc;
        loc = path.join(argv.db, file);
        if (page == null) {
            return fs.exists(loc, (function (_this) {
                return function (exists) {
                    var defloc;
                    if (exists) {
                        return load_parse(loc, cb);
                    } else {
                        defloc = path.join(argv.root, 'default-data', 'pages', file);
                        return fs.exists(defloc, function (exists) {
                            if (exists) {
                                return load_parse(defloc, cb);
                            } else {
                                return glob("wiki-plugin-*/pages", {
                                    cwd: argv.packageDir
                                }, function (e, plugins) {
                                    var giveUp, i, len, plugin, results;
                                    if (e) {
                                        return cb(e);
                                    }
                                    if (plugins.length === 0) {
                                        cb(null, 'Page not found', 404);
                                    }
                                    giveUp = (function () {
                                        var count;
                                        count = plugins.length;
                                        return function () {
                                            count -= 1;
                                            if (count === 0) {
                                                return cb(null, 'Page not found', 404);
                                            }
                                        };
                                    })();
                                    results = [];
                                    for (i = 0, len = plugins.length; i < len; i++) {
                                        plugin = plugins[i];
                                        results.push((function () {
                                            var pluginName, pluginloc;
                                            pluginName = plugin.slice(12, -6);
                                            pluginloc = path.join(argv.packageDir, plugin, file);
                                            return fs.exists(pluginloc, function (exists) {
                                                if (exists) {
                                                    return load_parse(pluginloc, cb, {
                                                        plugin: pluginName
                                                    });
                                                } else {
                                                    return giveUp();
                                                }
                                            });
                                        })());
                                    }
                                    return results;
                                });
                            }
                        });
                    }
                };
            })(this));
        } else {
            page = JSON.stringify(page, null, 2);
            return fs.exists(path.dirname(loc), function (exists) {
                if (exists) {
                    return fs.writeFile(loc, page, function (err) {
                        return cb(err);
                    });
                } else {
                    //return mkdirp(path.dirname(loc), function (err) {
                    return fs.mkdir(path.dirname(loc), function (err) {
                        if (err) {
                            cb(err);
                        }
                        return fs.writeFile(loc, page, function (err) {
                            return cb(err);
                        });
                    });
                }
            });
        }
    };
    working = false;
    serial = function (item) {
        if (item) {
            itself.start();
            return fileio(item.file, item.page, function (err, data, status) {
                process.nextTick(function () {
                    return serial(queue.shift());
                });
                return item.cb(err, data, status);
            });
        } else {
            return itself.stop();
        }
    };
    itself = new events.EventEmitter;
    itself.start = function () {
        working = true;
        return this.emit('working');
    };
    itself.stop = function () {
        working = false;
        return this.emit('finished');
    };
    itself.isWorking = function () {
        return working;
    };
    itself.get = function (file, cb) {
        queue.push({
            file: file,
            page: null,
            cb: cb
        });
        if (!working) {
            return serial(queue.shift());
        }
    };
    itself.put = function (file, page, cb) {
        queue.push({
            file: file,
            page: page,
            cb: cb
        });
        if (!working) {
            return serial(queue.shift());
        }
    };
    editDate = function (journal) {
        var action, i, ref;
        ref = journal || [];
        for (i = ref.length - 1; i >= 0; i += -1) {
            action = ref[i];
            if (action.date && action.type !== 'fork') {
                return action.date;
            }
        }
        return void 0;
    };
    itself.pages = function (cb) {
        return fs.readdir(argv.db, function (e, files) {
            var doSitemap;
            if (e) {
                return cb(e);
            }
            doSitemap = function (file, cb) {
                return itself.get(file, function (e, page, status) {
                    if (file.match(/^\./)) {
                        return cb();
                    }
                    if (e) {
                        console.log('Problem building sitemap:', file, 'e: ', e);
                        return cb();
                    }
                    return cb(null, {
                        slug: file,
                        title: page.title,
                        date: editDate(page.journal),
                        synopsis: synopsis(page)
                    });
                });
            };
            return async.map(files, doSitemap, function (e, sitemap) {
                if (e) {
                    return cb(e);
                }
                return cb(null, sitemap.filter(function (item) {
                    if (item != null) {
                        return true;
                    }
                }));
            });
        });
    };
    return itself;
};
